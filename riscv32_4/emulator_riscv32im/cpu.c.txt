//cpu
//#define next
//#define riscv.debug_inst
void execute_instruction()
{
    uint32_t opcode, rd, rs1, rs2, funct3,insn;
    int32_t imm=0, cond, err;
    uint32_t addr, val, val2,temp;

    insn = get_op(riscv.pc);//(memory_read(riscv.pc+3)<<24 |memory_read(riscv.pc+2)<<16 |memory_read(riscv.pc+1)<<8 |memory_read(riscv.pc));//get_insn32(riscv.pc);
    
    opcode = insn & 0x7f;
    rd = (insn >> 7) & 0x1f;
    rs1 = (insn >> 15) & 0x1f;
    rs2 = (insn >> 20) & 0x1f;
  
   if(riscv.debug_inst){
    temp = riscv.pc ;
    printf("instruction: %08x , pc: %08x\n", insn,temp);

    }
    switch(opcode) {
    case 0x37: /* lui */
        if (rd != 0)
            riscv.reg[rd] = (int32_t)(insn & 0xfffff000);

        if(riscv.debug_inst){
        printf("lui\n");
        printf("rd: %i , rd val: %x\n", rd, riscv.reg[rd]);
        printf("rs1: %i, %i\n",rs1,riscv.reg[rs1]);
        printf("rs2: %i, %i\n",rs2,riscv.reg[rs2]);
        printf("imm: %i\n",imm );
        }
        pc4;
        break;
    case 0x17: /* auipc */
        if (rd != 0)
            riscv.reg[rd] = (int32_t)(riscv.pc + (int32_t)(insn & 0xfffff000));

        if(riscv.debug_inst){
        printf("auipc :rd :%08x reg: %08x \n", rd,riscv.reg[rd]);
        }
        pc4;
        break;
    case 0x6f: /* jal */
        imm = ((insn >> (31 - 20)) & (1 << 20)) |
              ((insn >> (21 - 1)) & 0x7fe) |
              ((insn >> (20 - 11)) & (1 << 11)) |
              (insn & 0xff000);
        
        
         imm = (imm << 11) >> 11;

        if (rd != 0)
            riscv.reg[rd] = riscv.pc + 4;

        
        riscv.pc = (int32_t)(riscv.pc + imm);

        if(riscv.debug_inst){
        printf("JAL :pc :%08x reg: %i im:%08x \n", riscv.pc,rd,imm);
        }
        break;
    case 0x67: /* jalr */
        imm = (int32_t)insn >> 20;
        val = riscv.pc + 4;
        riscv.pc = (int32_t)(riscv.reg[rs1] + imm) & ~1;
        if(riscv.debug_inst){
        printf("jalr :%08x reg: %i\n", riscv.pc,rs1);
        }
        if (rd != 0)
            riscv.reg[rd] = val;
        break;
    case 0x63:
        funct3 = (insn >> 12) & 7;
        switch(funct3 >> 1) {
        case 0: /* beq/bne */
            cond = (riscv.reg[rs1] == riscv.reg[rs2]);
            break;
        case 2: /* blt/bge */
            cond = ((int32_t)riscv.reg[rs1] < (int32_t)riscv.reg[rs2]);
            break;
        case 3: /* bltu/bgeu */
            cond = (riscv.reg[rs1] < riscv.reg[rs2]);
            break;
        default:
            raise_exception(CAUSE_ILLEGAL_INSTRUCTION, insn);
            return;
        }
        cond ^= (funct3 & 1);
        if (cond) {
            imm = ((insn >> (31 - 12)) & (1 << 12)) |
                  ((insn >> (25 - 5)) & 0x7e0) |
                  ((insn >> (8 - 1)) & 0x1e) |
                  ((insn << (11 - 7)) & (1 << 11));
            imm = (imm << 19) >> 19;
            riscv.pc = (int32_t)(riscv.pc + imm);
            break;
        }else pc4;
        if(riscv.debug_inst){
        printf("compare\n");
        }
        break;
    case 0x03: /* load */
        funct3 = (insn >> 12) & 7;
        imm = (int32_t)insn >> 20;
        addr = riscv.reg[rs1] + imm;

        switch(funct3) {
        case 0: /* lb */
        {
            uint8_t rval;
            if(riscv.debug_inst){
            printf("lb\n");
            }
            if (target_read_u8(&rval, addr)) {
                raise_exception(riscv.pending_exception, riscv.pending_tval);
                return;
            }
            val = (int8_t)rval;
        }
        break;
        case 1: /* lh */
        {
            uint16_t rval;
            if (target_read_u16(&rval, addr)) {
                raise_exception(riscv.pending_exception, riscv.pending_tval);
                return;
            }
            val = (int16_t)rval;
        }
        break;
        case 2: /* lw */
        {
            if(riscv.debug_inst){
            printf("lw\n");
            }
            uint32_t rval;
            if (target_read_u32(&rval, addr)) {
                raise_exception(riscv.pending_exception, riscv.pending_tval);
                return;
            }
            val = (int32_t)rval;
        }
        break;
        case 4: /* lbu */
        {
            if(riscv.debug_inst){
            printf("lbu\n");
            }
            uint8_t rval;

            if (target_read_u8(&rval, addr)) {
                raise_exception(riscv.pending_exception, riscv.pending_tval);
                return;
            }
            val = rval;
        }
        break;
        case 5: /* lhu */
        {
            uint16_t rval;
            if (target_read_u16(&rval, addr)) {
                raise_exception(riscv.pending_exception, riscv.pending_tval);
                return;
            }
            val = rval;
        }
        break;
        default:
            raise_exception(CAUSE_ILLEGAL_INSTRUCTION, insn);
            return;
        }
        if (rd != 0)
            riscv.reg[rd] = val;

        if(riscv.debug_inst){
        printf("addr: %x\n",addr );
        printf("rd: %i , rd val: %x\n", rd, riscv.reg[rd]);
        printf("rs1: %i, %i\n",rs1,riscv.reg[rs1]);
        printf("rs2: %i, %i\n",rs2,riscv.reg[rs2]);
        printf("imm: %i\n",imm );
        printf("val: %x\n", val);
        }
        pc4;
        break;
    case 0x23: /* store */
        funct3 = (insn >> 12) & 7;
        imm = rd | ((insn >> (25 - 5)) & 0xfe0);
        imm = (imm << 20) >> 20;
        addr = riscv.reg[rs1] + imm;
        val = riscv.reg[rs2];
        //printf("addr: %x\n",addr);
        switch(funct3) {
        case 0: /* sb */
            if (target_write_u8(addr, val)) {
                raise_exception(riscv.pending_exception, riscv.pending_tval);
                return;
            }
            if(riscv.debug_inst){
            printf("sb\n");
            }
            break;
        case 1: /* sh */
            if (target_write_u16(addr, val)) {
                raise_exception(riscv.pending_exception, riscv.pending_tval);
                return;
            }
            break;
        case 2: /* sw */
            if (target_write_u32(addr, val)) {
                raise_exception(riscv.pending_exception, riscv.pending_tval);
                return;
            } 
            if(riscv.debug_inst){
            printf("sw\n");
            }
            break;
        default:
            raise_exception(CAUSE_ILLEGAL_INSTRUCTION, insn);
            return;
        }

        if(riscv.debug_inst){
        printf("addr: %x\n",addr);
        printf("val: %x\n", val);
        printf("rd: %i\n", rd);
        printf("rs1: %i, %x\n",rs1,riscv.reg[rs1]);
        printf("rs2: %i, %x\n",rs2,riscv.reg[rs2]);
        printf("imm: %x\n",imm );
        }
        pc4;
        break;
    case 0x13:
        funct3 = (insn >> 12) & 7;
        imm = (int32_t)insn >> 20;
        switch(funct3) {
        case 0: /* addi */
            val = (int32_t)(riscv.reg[rs1] + imm) ;//& 0x0000ffff;

            if(riscv.debug_inst){
            printf("addi/li : val: %x , reg1: %x , reg2: %x imm: %x\n",val,rs1,rs2,imm);
            }
            break;
        case 1: /* slli */
            if ((imm & ~(XLEN - 1)) != 0) {
                raise_exception(CAUSE_ILLEGAL_INSTRUCTION, insn);
                return;
            }
            val = (int32_t)(riscv.reg[rs1] << (imm & (XLEN - 1)));
            break;
        case 2: /* slti */
            val = (int32_t)riscv.reg[rs1] < (int32_t)imm;
            break;
        case 3: /* sltiu */
            val = riscv.reg[rs1] < (uint32_t)imm;
            break;
        case 4: /* xori */
            val = riscv.reg[rs1] ^ imm;
            break;
        case 5: /* srli/srai */
            if ((imm & ~((XLEN - 1) | 0x400)) != 0) {
                raise_exception(CAUSE_ILLEGAL_INSTRUCTION, insn);
                return;
            }
            if (imm & 0x400)
                val = (int32_t)riscv.reg[rs1] >> (imm & (XLEN - 1));
            else
                val = (int32_t)((uint32_t)riscv.reg[rs1] >> (imm & (XLEN - 1)));
            break;
        case 6: /* ori */
            val = riscv.reg[rs1] | imm;
            break;
        default:
        case 7: /* andi */
            val = riscv.reg[rs1] & imm;
            break;
        }
        if (rd != 0)
            riscv.reg[rd] = val;

        pc4;
        break;
    case 0x33:
        imm = insn >> 25;
        val = riscv.reg[rs1];
        val2 = riscv.reg[rs2];
        if (imm == 1) {
            funct3 = (insn >> 12) & 7;
            switch(funct3) {
            case 0: /* mul */
                val = (int32_t)((int32_t)val * (int32_t)val2);
                break;
            case 1: /* mulh */
                val = (int32_t)mulh32(val, val2);
                break;
            case 2:/* mulhsu */
                val = (int32_t)mulhsu32(val, val2);
                break;
            case 3:/* mulhu */
                val = (int32_t)mulhu32(val, val2);
                break;
            case 4:/* div */
                val = div32(val, val2);
                break;
            case 5:/* divu */
                val = (int32_t)divu32(val, val2);
                break;
            case 6:/* rem */
                val = rem32(val, val2);
                break;
            case 7:/* remu */
                val = (int32_t)remu32(val, val2);
                break;
            default:
                raise_exception(CAUSE_ILLEGAL_INSTRUCTION, insn);
                return;
            }
        } else {
            if (imm & ~0x20) {
                raise_exception(CAUSE_ILLEGAL_INSTRUCTION, insn);
                return;
            }
            funct3 = ((insn >> 12) & 7) | ((insn >> (30 - 3)) & (1 << 3));
            switch(funct3) {
            case 0: /* add */
                if(riscv.debug_inst){
                printf("add\n");
                }
                val = (int32_t)(val + val2);
                break;
            case 0 | 8: /* sub */
                val = (int32_t)(val - val2);
                break;
            case 1: /* sll */
                val = (int32_t)(val << (val2 & (XLEN - 1)));
                break;
            case 2: /* slt */
                val = (int32_t)val < (int32_t)val2;
                break;
            case 3: /* sltu */
                val = val < val2;
                break;
            case 4: /* xor */
                val = val ^ val2;
                break;
            case 5: /* srl */
                val = (int32_t)((uint32_t)val >> (val2 & (XLEN - 1)));
                break;
            case 5 | 8: /* sra */
                val = (int32_t)val >> (val2 & (XLEN - 1));
                break;
            case 6: /* or */
                val = val | val2;
                break;
            case 7: /* and */
                val = val & val2;
                break;
            default:
                raise_exception(CAUSE_ILLEGAL_INSTRUCTION, insn);
                return;
            }
        }
        if (rd != 0)
            riscv.reg[rd] = val;

        pc4;
        break;
        case 0x73:
        funct3 = (insn >> 12) & 7;
        imm = insn >> 20;
        if (funct3 & 4)
            val = rs1;
        else
            val = riscv.reg[rs1];
        funct3 &= 3;
        
        
        if(imm==2){//uret
           if(riscv.debug_inst){
              printf("(ret)temp: %08x , pc: %08x , cycles: %08x\n",riscv.temp2,riscv.pc,riscv.cycles);
           }
           riscv.pc = riscv.temp2;
        }else{
      switch(funct3) {
                  case 0:
                    if(riscv.debug_inst){
                       printf("ecall \n");
                       printf("a0: %08x \n", riscv.reg[10]);
                       printf("a7: %08x \n", riscv.reg[17]);
                    }
                
                    switch(riscv.reg[17]){
                          case 4://string 
                             while(memory_read(riscv.reg[10])!='\0'){
                                   printf("%c",memory_read(riscv.reg[10]));
                                   riscv.reg[10]++;
                             }
                          break;
                          case 5://readint
                               //printf("readint:\n");
                            scanf("%x",&riscv.reg[10]);
                            printf("%x\n",riscv.reg[10]);
                          break;
                          case 8:///readstring
                            //printf("readstring:\n");
                            //printf("a0: %08x \n", riscv.reg[10]);
                            //printf("a1: %08x \n", riscv.reg[11]);
                            /*char *p;
                            p=(char*)malloc(riscv.reg[11]);
                            scanf("%s",p);
                            printf("%s\n",p);*/
                          break;
                          case 10://exit
                            printf("EXIT RISCV32\n");
                            riscv.running=0;
                          break;
                          case 11://print char

                             printf("%c",(char)riscv.reg[10]);
                          break;
                          case 12:
                             //printf("ecall jump %x\n", riscv.reg[10]);
                             riscv.pc = riscv.reg[10]-4;
                          break;
                          case 13:
                             //printf("                         ecall kernel mode\n");
                          break;
                          case 14://open file
                             {
                               
                              int i=0;
                              int j=0;
                              strcpy(riscv.name,"");
                              while(memory_read(riscv.reg[10])!='\0'){
                                   riscv.name[i]=memory_read(riscv.reg[10]);
                                   riscv.reg[10]++;
                                   i++;
                              }
                              riscv.name[i]='\0';
                              i=strlen(riscv.name);
                              //name[i-1]='\0';
                              //printf("file: %s\n",riscv.name);
                              filebin = fopen(riscv.name, "rb");
                              if(filebin == NULL){
                                 riscv.wreg2=1;
                              }else{
                                 riscv.wreg2=0;
                              }
                            }
                          break;
              case 15:
                
                {
                  char c;
                  if(filebin!=NULL){
                        /*while ((c = getc(filebin)) != EOF){
                                
                    }*/
                  riscv.wreg3=getc(filebin);  
                  }
                }
              break;
              case 16:
                
                {
                  fseek(filebin, 0, SEEK_END);
                  riscv.wreg3 = ftell(filebin);
                  rewind(filebin);
                }
                            //printf("rcv cpu: size file\n");
              break;
              case 17:
                 fclose(filebin);
                 //printf("rcv cpu: close file\n");
              break;
                    }
                break;
           }
           pc4;
    }
       break;
    }
}
/***********************************************************/
 

int kbhit(){
struct timeval tv;
fd_set rdfs;
tv.tv_sec=0;
tv.tv_usec=0;
FD_ZERO(&rdfs);
FD_SET(STDIN_FILENO,&rdfs);
select(STDIN_FILENO+1,&rdfs,NULL,NULL,&tv);
return FD_ISSET(STDIN_FILENO,&rdfs);

}


int a;
void init_soc(){
  printf("RISCV32IM VIRTUAL CPU\n"); 
  riscv.next=0;
  riscv.debug_inst=0;

  while(riscv.running){

    if(riscv.next){
       scanf("%i",&a);
    }
    execute_instruction();
    if(riscv.enable_timer){
        if(!(riscv.cycles % 2500)){
             if(riscv.debug_inst){
                printf("(jmp)temp: %08x , cycles: %08x\n",riscv.pc,riscv.cycles);
             } 
             riscv.temp2 = riscv.pc;
             
             riscv.pc = vector_interrupt;
             riscv.cycles=0;
             counter_timer++;
        } 
    }
    riscv.cycles++;
  }
}



